import streamlit as st
import pandas as pd
from typing import Optional, Dict, Any, List
import json
from data_manager import data_manager
from chart_generator import ChartDetector
import plotly.express as px
import plotly.graph_objects as go

class SimpleChat:
    """Sistema de chat simplificado e eficaz"""
    
    def __init__(self):
        self.chart_detector = ChartDetector()
        self.suggestions = [
            "Quais s√£o os tipos de dados das colunas?",
            "Quantos registros existem no dataset?",
            "Quais colunas t√™m valores ausentes?",
            "Mostre a distribui√ß√£o da coluna [nome_da_coluna]",
            "Quais s√£o os valores √∫nicos em [coluna_categ√≥rica]?",
            "Calcule estat√≠sticas descritivas das colunas num√©ricas",
            "Identifique poss√≠veis outliers nos dados",
            "Mostre a correla√ß√£o entre vari√°veis num√©ricas",
            "Qual √© a tend√™ncia temporal dos dados?",
            "Resuma os principais insights dos dados"
        ]
    
    def get_data_context(self) -> str:
        """Gera contexto dos dados atuais"""
        df = data_manager.get_current_data()
        if df is None:
            return "Nenhum dado carregado."
        
        summary = data_manager.get_data_summary()
        context = f"""
DADOS CARREGADOS:
- Arquivo: {data_manager.get_current_filename()}
- Registros: {summary.get('total_records', 0):,}
- Colunas: {summary.get('total_columns', 0)}
- Colunas num√©ricas: {', '.join(summary.get('numeric_columns', []))}
- Colunas categ√≥ricas: {', '.join(summary.get('categorical_columns', []))}

ESTAT√çSTICAS B√ÅSICAS:
"""
        
        # Adicionar estat√≠sticas b√°sicas
        basic_stats = summary.get('basic_stats', {})
        for col, stats in basic_stats.items():
            if isinstance(stats, dict):
                context += f"\n{col}:\n"
                for stat_name, value in stats.items():
                    if isinstance(value, (int, float)):
                        context += f"  {stat_name}: {value:.2f}\n"
        
        # Adicionar valores √∫nicos para colunas categ√≥ricas
        categorical_cols = summary.get('categorical_columns', [])
        if categorical_cols:
            context += "\nVALORES √öNICOS (colunas categ√≥ricas):\n"
            for col in categorical_cols[:5]:  # Limitar a 5 colunas
                unique_count = df[col].nunique()
                context += f"- {col}: {unique_count} valores √∫nicos\n"
        
        return context
    
    def get_analysis_context(self) -> str:
        """Gera contexto das an√°lises CrewAI dispon√≠veis"""
        available_analyses = data_manager.get_available_analyses()
        if not available_analyses:
            return "Nenhuma an√°lise CrewAI dispon√≠vel."
        
        context = "AN√ÅLISES CREWAI DISPON√çVEIS:\n"
        for analysis_name in available_analyses:
            results = data_manager.load_analysis(analysis_name)
            if results:
                context += f"\n{analysis_name.upper()}:\n"
                for agent_name, agent_data in results.items():
                    status = agent_data.get('status', 'unknown')
                    result = agent_data.get('result', 'Nenhum resultado')
                    context += f"- {agent_name}: {status}\n"
                    if isinstance(result, str) and len(result) > 0:
                        # Limitar tamanho para n√£o sobrecarregar o prompt
                        context += f"  {result[:500]}{'...' if len(result) > 500 else ''}\n"
        
        return context
    
    def generate_response(self, user_message: str) -> tuple[str, Optional[Any]]:
        """Gera resposta do chat"""
        try:
            # Verificar se precisa de gr√°fico
            needs_chart, chart_type = self.chart_detector.needs_chart(user_message)
            
            if needs_chart:
                return self._generate_chart_response(user_message, chart_type)
            else:
                return self._generate_text_response(user_message)
                
        except Exception as e:
            return self._generate_fallback_response(user_message, str(e))
    
    def _generate_chart_response(self, user_message: str, chart_type: str) -> tuple[str, Optional[Any]]:
        """Gera resposta com gr√°fico"""
        df = data_manager.get_current_data()
        if df is None:
            return "‚ùå Nenhum dado carregado para gerar gr√°fico.", None
        
        try:
            # Gerar gr√°fico baseado no tipo
            if chart_type == "histogram":
                return self._create_histogram(df, user_message)
            elif chart_type == "scatter":
                return self._create_scatter(df, user_message)
            elif chart_type == "bar":
                return self._create_bar_chart(df, user_message)
            elif chart_type == "line":
                return self._create_line_chart(df, user_message)
            else:
                return self._create_general_chart(df, user_message)
                
        except Exception as e:
            return f"‚ùå Erro ao gerar gr√°fico: {str(e)}", None
    
    def _create_histogram(self, df: pd.DataFrame, user_message: str) -> tuple[str, Optional[Any]]:
        """Cria histograma"""
        numeric_cols = df.select_dtypes(include=['number']).columns.tolist()
        if not numeric_cols:
            return "‚ùå Nenhuma coluna num√©rica encontrada para histograma.", None
        
        # Tentar identificar coluna espec√≠fica na mensagem
        selected_col = None
        for col in numeric_cols:
            if col.lower() in user_message.lower():
                selected_col = col
                break
        
        if not selected_col:
            selected_col = numeric_cols[0]
        
        fig = px.histogram(df, x=selected_col, title=f"Distribui√ß√£o de {selected_col}")
        response = f"üìä Histograma da coluna '{selected_col}' gerado com sucesso!"
        return response, fig
    
    def _create_scatter(self, df: pd.DataFrame, user_message: str) -> tuple[str, Optional[Any]]:
        """Cria gr√°fico de dispers√£o"""
        numeric_cols = df.select_dtypes(include=['number']).columns.tolist()
        if len(numeric_cols) < 2:
            return "‚ùå S√£o necess√°rias pelo menos 2 colunas num√©ricas para gr√°fico de dispers√£o.", None
        
        x_col = numeric_cols[0]
        y_col = numeric_cols[1]
        
        fig = px.scatter(df, x=x_col, y=y_col, title=f"Correla√ß√£o: {x_col} vs {y_col}")
        response = f"üìä Gr√°fico de dispers√£o: {x_col} vs {y_col}"
        return response, fig
    
    def _create_bar_chart(self, df: pd.DataFrame, user_message: str) -> tuple[str, Optional[Any]]:
        """Cria gr√°fico de barras"""
        categorical_cols = df.select_dtypes(include=['object']).columns.tolist()
        if not categorical_cols:
            return "‚ùå Nenhuma coluna categ√≥rica encontrada para gr√°fico de barras.", None
        
        selected_col = categorical_cols[0]
        value_counts = df[selected_col].value_counts().head(10)
        
        fig = px.bar(x=value_counts.index, y=value_counts.values, 
                    title=f"Frequ√™ncia de {selected_col}")
        response = f"üìä Gr√°fico de barras da coluna '{selected_col}'"
        return response, fig
    
    def _create_line_chart(self, df: pd.DataFrame, user_message: str) -> tuple[str, Optional[Any]]:
        """Cria gr√°fico de linha"""
        numeric_cols = df.select_dtypes(include=['number']).columns.tolist()
        if not numeric_cols:
            return "‚ùå Nenhuma coluna num√©rica encontrada para gr√°fico de linha.", None
        
        selected_col = numeric_cols[0]
        fig = px.line(df, y=selected_col, title=f"Tend√™ncia de {selected_col}")
        response = f"üìä Gr√°fico de linha da coluna '{selected_col}'"
        return response, fig
    
    def _create_general_chart(self, df: pd.DataFrame, user_message: str) -> tuple[str, Optional[Any]]:
        """Cria gr√°fico geral baseado nos dados"""
        numeric_cols = df.select_dtypes(include=['number']).columns.tolist()
        categorical_cols = df.select_dtypes(include=['object']).columns.tolist()
        
        if numeric_cols and categorical_cols:
            # Box plot: num√©rico vs categ√≥rico
            fig = px.box(df, x=categorical_cols[0], y=numeric_cols[0], 
                        title=f"Distribui√ß√£o de {numeric_cols[0]} por {categorical_cols[0]}")
            response = f"üìä Box plot: {numeric_cols[0]} por {categorical_cols[0]}"
        elif numeric_cols:
            # Histograma da primeira coluna num√©rica
            fig = px.histogram(df, x=numeric_cols[0], title=f"Distribui√ß√£o de {numeric_cols[0]}")
            response = f"üìä Histograma da coluna '{numeric_cols[0]}'"
        else:
            # Gr√°fico de barras da primeira coluna categ√≥rica
            value_counts = df[categorical_cols[0]].value_counts().head(10)
            fig = px.bar(x=value_counts.index, y=value_counts.values, 
                        title=f"Frequ√™ncia de {categorical_cols[0]}")
            response = f"üìä Gr√°fico de barras da coluna '{categorical_cols[0]}'"
        
        return response, fig
    
    def _generate_text_response(self, user_message: str) -> tuple[str, Optional[Any]]:
        """Gera resposta textual baseada nos dados"""
        df = data_manager.get_current_data()
        if df is None:
            return "‚ùå Nenhum dado carregado. Carregue um arquivo CSV primeiro.", None
        
        # Respostas baseadas em padr√µes comuns
        user_lower = user_message.lower()
        
        if "tipos de dados" in user_lower or "tipos" in user_lower:
            return self._answer_data_types(df)
        elif "registros" in user_lower or "linhas" in user_lower:
            return self._answer_records_count(df)
        elif "colunas" in user_lower and "ausentes" in user_lower:
            return self._answer_missing_values(df)
        elif "estat√≠sticas" in user_lower or "descritivas" in user_lower:
            return self._answer_descriptive_stats(df)
        elif "valores √∫nicos" in user_lower:
            return self._answer_unique_values(df)
        elif "outliers" in user_lower:
            return self._answer_outliers(df)
        elif "correla√ß√£o" in user_lower:
            return self._answer_correlation(df)
        elif "insights" in user_lower or "conclus√µes" in user_lower:
            return self._answer_insights()
        else:
            return self._answer_general_question(user_message, df)
    
    def _answer_data_types(self, df: pd.DataFrame) -> tuple[str, Optional[Any]]:
        """Responde sobre tipos de dados"""
        response = "üìä **Tipos de Dados das Colunas:**\n\n"
        for col in df.columns:
            dtype = str(df[col].dtype)
            response += f"‚Ä¢ **{col}**: {dtype}\n"
        return response, None
    
    def _answer_records_count(self, df: pd.DataFrame) -> tuple[str, Optional[Any]]:
        """Responde sobre n√∫mero de registros"""
        response = f"üìä **Total de Registros:** {len(df):,}\n"
        response += f"üìä **Total de Colunas:** {len(df.columns)}\n"
        return response, None
    
    def _answer_missing_values(self, df: pd.DataFrame) -> tuple[str, Optional[Any]]:
        """Responde sobre valores ausentes"""
        missing = df.isnull().sum()
        response = "üìä **Valores Ausentes por Coluna:**\n\n"
        for col, count in missing.items():
            if count > 0:
                percentage = (count / len(df)) * 100
                response += f"‚Ä¢ **{col}**: {count:,} ({percentage:.1f}%)\n"
        
        if missing.sum() == 0:
            response += "‚úÖ Nenhum valor ausente encontrado!"
        
        return response, None
    
    def _answer_descriptive_stats(self, df: pd.DataFrame) -> tuple[str, Optional[Any]]:
        """Responde sobre estat√≠sticas descritivas"""
        numeric_cols = df.select_dtypes(include=['number']).columns.tolist()
        if not numeric_cols:
            return "‚ùå Nenhuma coluna num√©rica encontrada para estat√≠sticas descritivas.", None
        
        response = "üìä **Estat√≠sticas Descritivas:**\n\n"
        stats = df[numeric_cols].describe()
        
        for col in numeric_cols:
            response += f"**{col}:**\n"
            response += f"‚Ä¢ M√©dia: {stats.loc['mean', col]:.2f}\n"
            response += f"‚Ä¢ Mediana: {stats.loc['50%', col]:.2f}\n"
            response += f"‚Ä¢ Desvio Padr√£o: {stats.loc['std', col]:.2f}\n"
            response += f"‚Ä¢ M√≠nimo: {stats.loc['min', col]:.2f}\n"
            response += f"‚Ä¢ M√°ximo: {stats.loc['max', col]:.2f}\n\n"
        
        return response, None
    
    def _answer_unique_values(self, df: pd.DataFrame) -> tuple[str, Optional[Any]]:
        """Responde sobre valores √∫nicos"""
        response = "üìä **Valores √önicos por Coluna:**\n\n"
        for col in df.columns:
            unique_count = df[col].nunique()
            response += f"‚Ä¢ **{col}**: {unique_count:,} valores √∫nicos\n"
        return response, None
    
    def _answer_outliers(self, df: pd.DataFrame) -> tuple[str, Optional[Any]]:
        """Responde sobre outliers"""
        numeric_cols = df.select_dtypes(include=['number']).columns.tolist()
        if not numeric_cols:
            return "‚ùå Nenhuma coluna num√©rica encontrada para an√°lise de outliers.", None
        
        response = "üìä **An√°lise de Outliers:**\n\n"
        for col in numeric_cols[:5]:  # Limitar a 5 colunas
            Q1 = df[col].quantile(0.25)
            Q3 = df[col].quantile(0.75)
            IQR = Q3 - Q1
            outliers = df[(df[col] < (Q1 - 1.5 * IQR)) | (df[col] > (Q3 + 1.5 * IQR))]
            response += f"‚Ä¢ **{col}**: {len(outliers)} outliers\n"
        
        return response, None
    
    def _answer_correlation(self, df: pd.DataFrame) -> tuple[str, Optional[Any]]:
        """Responde sobre correla√ß√£o"""
        numeric_cols = df.select_dtypes(include=['number']).columns.tolist()
        if len(numeric_cols) < 2:
            return "‚ùå S√£o necess√°rias pelo menos 2 colunas num√©ricas para an√°lise de correla√ß√£o.", None
        
        corr_matrix = df[numeric_cols].corr()
        response = "üìä **Correla√ß√µes Significativas:**\n\n"
        
        # Encontrar correla√ß√µes fortes
        strong_correlations = []
        for i in range(len(numeric_cols)):
            for j in range(i + 1, len(numeric_cols)):
                corr_value = corr_matrix.iloc[i, j]
                if abs(corr_value) > 0.7:
                    strong_correlations.append((numeric_cols[i], numeric_cols[j], corr_value))
        
        if strong_correlations:
            for col1, col2, corr in strong_correlations:
                response += f"‚Ä¢ **{col1}** ‚Üî **{col2}**: {corr:.3f}\n"
        else:
            response += "Nenhuma correla√ß√£o forte (>0.7) encontrada entre as vari√°veis num√©ricas.\n"
        
        return response, None
    
    def _answer_insights(self) -> tuple[str, Optional[Any]]:
        """Responde sobre insights das an√°lises CrewAI"""
        analysis_context = self.get_analysis_context()
        if "Nenhuma an√°lise CrewAI dispon√≠vel" in analysis_context:
            return "‚ùå Nenhuma an√°lise CrewAI dispon√≠vel. Execute uma an√°lise primeiro.", None
        
        response = "üéØ **Insights das An√°lises CrewAI:**\n\n"
        response += analysis_context
        return response, None
    
    def _answer_general_question(self, user_message: str, df: pd.DataFrame) -> tuple[str, Optional[Any]]:
        """Responde perguntas gerais"""
        # Tentar extrair informa√ß√µes espec√≠ficas da pergunta
        if "maior" in user_message.lower() or "m√°ximo" in user_message.lower():
            return self._answer_max_values(df, user_message)
        elif "menor" in user_message.lower() or "m√≠nimo" in user_message.lower():
            return self._answer_min_values(df, user_message)
        elif "m√©dia" in user_message.lower() or "m√©dio" in user_message.lower():
            return self._answer_mean_values(df, user_message)
        else:
            return self._answer_data_overview(df)
    
    def _answer_max_values(self, df: pd.DataFrame, user_message: str) -> tuple[str, Optional[Any]]:
        """Responde sobre valores m√°ximos"""
        numeric_cols = df.select_dtypes(include=['number']).columns.tolist()
        if not numeric_cols:
            return "‚ùå Nenhuma coluna num√©rica encontrada.", None
        
        response = "üìä **Valores M√°ximos:**\n\n"
        for col in numeric_cols:
            max_val = df[col].max()
            response += f"‚Ä¢ **{col}**: {max_val:.2f}\n"
        return response, None
    
    def _answer_min_values(self, df: pd.DataFrame, user_message: str) -> tuple[str, Optional[Any]]:
        """Responde sobre valores m√≠nimos"""
        numeric_cols = df.select_dtypes(include=['number']).columns.tolist()
        if not numeric_cols:
            return "‚ùå Nenhuma coluna num√©rica encontrada.", None
        
        response = "üìä **Valores M√≠nimos:**\n\n"
        for col in numeric_cols:
            min_val = df[col].min()
            response += f"‚Ä¢ **{col}**: {min_val:.2f}\n"
        return response, None
    
    def _answer_mean_values(self, df: pd.DataFrame, user_message: str) -> tuple[str, Optional[Any]]:
        """Responde sobre valores m√©dios"""
        numeric_cols = df.select_dtypes(include=['number']).columns.tolist()
        if not numeric_cols:
            return "‚ùå Nenhuma coluna num√©rica encontrada.", None
        
        response = "üìä **Valores M√©dios:**\n\n"
        for col in numeric_cols:
            mean_val = df[col].mean()
            response += f"‚Ä¢ **{col}**: {mean_val:.2f}\n"
        return response, None
    
    def _answer_data_overview(self, df: pd.DataFrame) -> tuple[str, Optional[Any]]:
        """Responde com vis√£o geral dos dados"""
        response = "üìä **Vis√£o Geral dos Dados:**\n\n"
        response += f"‚Ä¢ **Total de registros**: {len(df):,}\n"
        response += f"‚Ä¢ **Total de colunas**: {len(df.columns)}\n"
        response += f"‚Ä¢ **Colunas num√©ricas**: {len(df.select_dtypes(include=['number']).columns)}\n"
        response += f"‚Ä¢ **Colunas categ√≥ricas**: {len(df.select_dtypes(include=['object']).columns)}\n"
        response += f"‚Ä¢ **Valores ausentes**: {df.isnull().sum().sum():,}\n"
        response += f"‚Ä¢ **Registros duplicados**: {df.duplicated().sum():,}\n"
        return response, None
    
    def _generate_fallback_response(self, user_message: str, error: str) -> tuple[str, Optional[Any]]:
        """Gera resposta de fallback quando h√° erro"""
        df = data_manager.get_current_data()
        if df is None:
            return "‚ùå Nenhum dado carregado. Carregue um arquivo CSV primeiro.", None
        
        return f"‚ö†Ô∏è Erro ao processar pergunta: {error}\n\nüìä Dados dispon√≠veis: {len(df):,} registros √ó {len(df.columns)} colunas", None
    
    def show_suggestions(self):
        """Mostra sugest√µes de perguntas em 2 colunas"""
        if self.suggestions:
            st.markdown("#### üí° Sugest√µes de Perguntas:")
            col1, col2 = st.columns(2)
            mid_point = len(self.suggestions) // 2
            suggestions_col1 = self.suggestions[:mid_point]
            suggestions_col2 = self.suggestions[mid_point:]
            
            with col1:
                for suggestion in suggestions_col1:
                    st.markdown(f"‚Ä¢ {suggestion}")
            
            with col2:
                for suggestion in suggestions_col2:
                    st.markdown(f"‚Ä¢ {suggestion}")

# Inst√¢ncia global do SimpleChat
simple_chat = SimpleChat()
