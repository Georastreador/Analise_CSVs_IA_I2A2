# M√≥dulo de Chat com IA - Vers√£o Melhorada com Integra√ß√£o CrewAI
# Estilo ChatGPT com an√°lise de dados e acesso √†s conclus√µes dos agentes

import streamlit as st
import pandas as pd
import json
from datetime import datetime
import os
import base64
import uuid

# Importar sistema de mem√≥ria
from analysis_memory import analysis_memory

# Importar sistema CrewAI
from crewai_agents import CSVAnalysisCrew, analyze_csv_with_crewai

# Importar sistema de gera√ß√£o de gr√°ficos
from chart_generator import generate_chart_for_question, create_pygwalker_interface
import plotly.graph_objects as go

# Importar visualiza√ß√µes avan√ßadas
from visualization_enhanced import generate_visualization_insights

# Importa√ß√µes para APIs de IA
try:
    from openai import OpenAI
except ImportError:
    OpenAI = None

try:
    from groq import Groq
except ImportError:
    Groq = None

try:
    import google.generativeai as genai
except ImportError:
    genai = None

try:
    from anthropic import Anthropic
except ImportError:
    Anthropic = None

try:
    import requests
    Perplexity = "requests_available"
except ImportError:
    Perplexity = None

class EnhancedChatAI:
    def __init__(self, api_provider="OpenAI", api_key=None):
        self.api_provider = api_provider
        self.api_key = api_key
        self.client = None
        self.setup_client()
    
    def setup_client(self):
        """Configura o cliente da API selecionada"""
        if not self.api_key:
            return
        
        try:
            if self.api_provider == "OpenAI":
                self.client = OpenAI(api_key=self.api_key)
            elif self.api_provider == "GROQ":
                self.client = Groq(api_key=self.api_key)
            elif self.api_provider == "Gemini":
                genai.configure(api_key=self.api_key)
                self.client = genai.GenerativeModel('gemini-pro')
            elif self.api_provider == "Claude":
                self.client = Anthropic(api_key=self.api_key)
            elif self.api_provider == "Perplexity":
                self.client = {"api_key": self.api_key}
        except Exception as e:
            st.error(f"‚ùå Erro ao configurar cliente {self.api_provider}: {str(e)}")
    
    def run_crewai_analysis(self, df: pd.DataFrame, analysis_name: str = "An√°lise CSV") -> str:
        """
        Executa an√°lise completa com agentes CrewAI
        
        Args:
            df: DataFrame com os dados
            analysis_name: Nome da an√°lise
        
        Returns:
            String com ID da an√°lise executada
        """
        try:
            # Gerar ID √∫nico para a an√°lise
            analysis_id = str(uuid.uuid4())[:8]
            
            # Executar an√°lise com CrewAI
            st.info("ü§ñ Executando an√°lise com agentes CrewAI...")
            crew_results = analyze_csv_with_crewai(df, analysis_name)
            
            # Salvar resultados na mem√≥ria
            success = analysis_memory.save_analysis_results(
                analysis_id=analysis_id,
                csv_data=df,
                crew_results=crew_results,
                analysis_name=analysis_name
            )
            
            if success:
                st.success(f"‚úÖ An√°lise conclu√≠da! ID: {analysis_id}")
                return analysis_id
            else:
                st.error("‚ùå Erro ao salvar resultados da an√°lise")
                return None
                
        except Exception as e:
            st.error(f"‚ùå Erro na an√°lise CrewAI: {str(e)}")
            return None
    
    def get_analysis_context(self, analysis_id: str = None) -> str:
        """
        Gera contexto sobre as an√°lises dispon√≠veis
        
        Args:
            analysis_id: ID da an√°lise espec√≠fica (None para an√°lise atual)
        
        Returns:
            String com contexto das an√°lises
        """
        if analysis_id is None:
            analysis_id = analysis_memory.current_analysis
        
        if not analysis_id:
            return "Nenhuma an√°lise CrewAI dispon√≠vel. Execute uma an√°lise primeiro."
        
        # Obter dados da an√°lise
        analysis_data = analysis_memory.get_analysis_results(analysis_id)
        if not analysis_data:
            return "An√°lise n√£o encontrada."
        
        # Obter conclus√µes dos agentes
        conclusions = analysis_memory.get_agent_conclusions(analysis_id)
        
        context = f"""
AN√ÅLISE CREWAI DISPON√çVEL:
- ID: {analysis_id}
- Nome: {analysis_data.get('analysis_name', 'N/A')}
- Data: {analysis_data.get('timestamp', 'N/A')}
- Registros: {analysis_data.get('data_summary', {}).get('rows', 0):,}
- Colunas: {analysis_data.get('data_summary', {}).get('columns', 0)}

CONCLUS√ïES DOS AGENTES:
"""
        
        # Adicionar conclus√µes de cada agente
        for agent_name, agent_data in conclusions.items():
            status = agent_data.get('status', 'unknown')
            result = agent_data.get('result', 'Nenhum resultado')
            
            # Incluir resultado completo para insights estrat√©gicos
            if isinstance(result, str):
                # Para insights estrat√©gicos, incluir resultado completo
                context += f"{agent_name}: {status}\n{result}\n\n"
            elif isinstance(result, dict):
                # Se for dict, converter para string formatada
                context += f"{agent_name}: {status}\n{json.dumps(result, indent=2, ensure_ascii=False)}\n\n"
            else:
                context += f"{agent_name}: {status} - {str(result)}\n\n"
        
        return context
    
    def generate_enhanced_response(self, user_message: str, df: pd.DataFrame = None, 
                                 analysis_name: str = "An√°lise CSV") -> tuple:
        """
        Gera resposta da IA com acesso √†s conclus√µes dos agentes CrewAI e gr√°ficos
        
        Args:
            user_message: Mensagem do usu√°rio
            df: DataFrame com os dados
            analysis_name: Nome da an√°lise
        
        Returns:
            Tuple[str, Optional[go.Figure]]: (resposta_texto, grafico)
        """
        if not self.client:
            return ("‚ùå Cliente de IA n√£o configurado. Verifique sua chave de API.", None)
        
        try:
            # Verificar se √© uma solicita√ß√£o para executar an√°lise CrewAI
            execute_analysis_keywords = [
                "execute", "executar", "an√°lise completa", "an√°lise com agentes", "crewai",
                "agentes", "an√°lise crewai", "execute an√°lise", "executar an√°lise"
            ]
            
            is_execute_request = any(keyword in user_message.lower() for keyword in execute_analysis_keywords)
            
            # Verificar se √© uma pergunta sobre an√°lises CrewAI
            crewai_keywords = [
                "conclus√£o", "conclus√µes", "resultado", "resultados", "insight", "insights",
                "an√°lise", "agente", "agentes", "crewai", "crew", "descoberta", "descobertas",
                "padr√£o", "padr√µes", "anomalia", "anomalias", "correla√ß√£o", "correla√ß√µes",
                "recomenda√ß√£o", "recomenda√ß√µes", "estrat√©gia", "estrat√©gico"
            ]
            
            is_crewai_question = any(keyword in user_message.lower() for keyword in crewai_keywords)
            
            # Se for uma solicita√ß√£o para executar an√°lise, executar primeiro
            if is_execute_request and df is not None:
                return self._handle_execute_analysis_request(df, analysis_name)
            
            # Obter contexto das an√°lises se dispon√≠vel
            analysis_context = ""
            if analysis_memory.current_analysis or is_crewai_question:
                analysis_context = self.get_analysis_context()
            
            # Obter contexto dos dados se dispon√≠vel
            data_context = ""
            if df is not None:
                data_context = self.analyze_data_context(df, analysis_name)
                
                # Adicionar estat√≠sticas b√°sicas dos dados
                numeric_cols = df.select_dtypes(include=['number']).columns
                if len(numeric_cols) > 0:
                    data_context += f"\n\nESTAT√çSTICAS B√ÅSICAS DOS DADOS:\n"
                    for col in numeric_cols[:10]:  # Limitar a 10 colunas
                        min_val = df[col].min()
                        max_val = df[col].max()
                        mean_val = df[col].mean()
                        data_context += f"- {col}: Min={min_val:.2f}, Max={max_val:.2f}, M√©dia={mean_val:.2f}\n"
            
            # Construir prompt do sistema
            system_prompt = f"""
Voc√™ √© um assistente especializado em an√°lise de dados com acesso aos resultados de agentes CrewAI.

{analysis_context}

{data_context}

INSTRU√á√ïES CR√çTICAS:
- Voc√™ TEM ACESSO COMPLETO aos dados CSV carregados e aos resultados de 6 agentes CrewAI especializados
- Use SEMPRE os dados CSV quando dispon√≠veis - N√ÉO diga que n√£o tem acesso aos dados
- Para perguntas sobre estat√≠sticas, intervalos, valores min/max, use os dados CSV fornecidos acima
- Use SEMPRE as conclus√µes dos agentes quando dispon√≠veis - N√ÉO invente informa√ß√µes
- Se perguntado sobre conclus√µes, insights ou recomenda√ß√µes, consulte EXATAMENTE os resultados dos agentes
- Responda em portugu√™s brasileiro
- Seja espec√≠fico e detalhado sobre as descobertas dos agentes e dados
- NUNCA diga que n√£o tem acesso √†s conclus√µes ou dados se eles est√£o dispon√≠veis acima

FUNCIONALIDADES DISPON√çVEIS:
- ‚úÖ 6 Agentes CrewAI: Data Validator, Data Profiler, Pattern Detective, Anomaly Hunter, Relationship Analyst, Strategic Synthesizer
- ‚úÖ Acesso COMPLETO √†s conclus√µes espec√≠ficas de cada agente
- ‚úÖ An√°lise de correla√ß√µes e padr√µes
- ‚úÖ Detec√ß√£o de anomalias
- ‚úÖ Recomenda√ß√µes estrat√©gicas
- ‚úÖ Hist√≥rico de an√°lises

QUANDO USU√ÅRIO PERGUNTAR SOBRE DADOS (estat√≠sticas, intervalos, min/max, etc.):
- Use SEMPRE os dados CSV fornecidos acima
- Para perguntas sobre intervalos (min/max), use as estat√≠sticas b√°sicas dos dados
- Para perguntas sobre distribui√ß√µes, use os insights das visualiza√ß√µes
- NUNCA diga que n√£o tem acesso aos dados - eles est√£o dispon√≠veis acima

QUANDO USU√ÅRIO PERGUNTAR SOBRE CONCLUS√ïES/INSIGHTS/RECOMENDA√á√ïES:
- Consulte EXATAMENTE as conclus√µes dos agentes fornecidas acima
- Para perguntas sobre "resumo executivo", use EXATAMENTE o texto do **Resumo Executivo** do Data Validator
- Para perguntas sobre "insights principais" ou "principais insights", use EXATAMENTE o texto da se√ß√£o **Insights Principais** do Data Validator
- N√ÉO interprete, resuma ou modifique o texto do agente - use o texto EXATO
- Cite especificamente o que cada agente descobriu
- Mencione insights, padr√µes, anomalias e recomenda√ß√µes encontradas
- Use as informa√ß√µes EXATAS dos agentes, n√£o generalize

IMPORTANTE: 
- Os dados CSV est√£o dispon√≠veis acima com estat√≠sticas b√°sicas
- As conclus√µes dos agentes est√£o dispon√≠veis acima
- Use SEMPRE essas informa√ß√µes para responder, n√£o invente ou diga que n√£o tem acesso
"""
            
            # Preparar mensagens
            messages = [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_message}
            ]
            
            # Gerar resposta baseada no provedor
            text_response = ""
            try:
                if self.api_provider == "OpenAI":
                    response = self.client.chat.completions.create(
                        model="gpt-4",
                        messages=messages,
                        max_tokens=1500,
                        temperature=0.7,
                        timeout=30  # Timeout de 30 segundos
                    )
                    text_response = response.choices[0].message.content
            
                elif self.api_provider == "GROQ":
                    response = self.client.chat.completions.create(
                        model="llama-3.1-8b-instant",
                        messages=messages,
                        max_tokens=1500,
                        temperature=0.7,
                        timeout=30
                    )
                    text_response = response.choices[0].message.content
                
                elif self.api_provider == "Gemini":
                    prompt = f"{system_prompt}\n\n{user_message}"
                    response = self.client.generate_content(prompt)
                    text_response = response.text
                
                elif self.api_provider == "Claude":
                    response = self.client.messages.create(
                        model="claude-3-sonnet-20240229",
                        max_tokens=1500,
                        temperature=0.7,
                        messages=[
                            {"role": "user", "content": f"{system_prompt}\n\n{user_message}"}
                        ],
                        timeout=30
                    )
                    text_response = response.content[0].text
                
                elif self.api_provider == "Perplexity":
                    headers = {
                        "Authorization": f"Bearer {self.client['api_key']}",
                        "Content-Type": "application/json"
                    }
                    data = {
                        "model": "llama-3.1-sonar-small-128k-online",
                        "messages": messages,
                        "max_tokens": 1500,
                        "temperature": 0.7
                    }
                    response = requests.post(
                        "https://api.perplexity.ai/chat/completions",
                        headers=headers,
                        json=data,
                        timeout=30
                    )
                    if response.status_code == 200:
                        text_response = response.json()["choices"][0]["message"]["content"]
                    else:
                        text_response = f"‚ùå Erro Perplexity: {response.status_code} - {response.text}"
                
            except Exception as api_error:
                # Se houver erro na API, usar fallback
                raise Exception(f"Erro na API {self.api_provider}: {str(api_error)}")
            
            # Gerar gr√°fico se necess√°rio
            chart = None
            if df is not None and text_response:
                try:
                    chart = generate_chart_for_question(user_message, df)
                except Exception as e:
                    st.warning(f"‚ö†Ô∏è N√£o foi poss√≠vel gerar gr√°fico: {str(e)}")
            
            return (text_response, chart)
            
        except Exception as e:
            # Fallback: resposta b√°sica com dados dispon√≠veis
            fallback_response = self._generate_fallback_response(user_message, df, analysis_context)
            return (fallback_response, None)
    
    def _generate_fallback_response(self, user_message: str, df: pd.DataFrame = None, analysis_context: str = "") -> str:
        """Gera resposta de fallback quando h√° erro na API"""
        try:
            # Resposta b√°sica baseada nos dados dispon√≠veis
            if df is not None:
                numeric_cols = df.select_dtypes(include=['number']).columns
                categorical_cols = df.select_dtypes(include=['object']).columns
                
                if "tipos de dados" in user_message.lower():
                    return f"""**Tipos de Dados no Dataset:**
- **Total de colunas:** {len(df.columns)}
- **Colunas num√©ricas:** {len(numeric_cols)} ({', '.join(numeric_cols[:5])}{'...' if len(numeric_cols) > 5 else ''})
- **Colunas categ√≥ricas:** {len(categorical_cols)} ({', '.join(categorical_cols[:5])}{'...' if len(categorical_cols) > 5 else ''})
- **Total de registros:** {len(df):,}"""
                
                elif "intervalo" in user_message.lower() or "m√≠nimo" in user_message.lower() or "m√°ximo" in user_message.lower():
                    response = "**Intervalos das Vari√°veis Num√©ricas:**\n"
                    for col in numeric_cols[:10]:
                        min_val = df[col].min()
                        max_val = df[col].max()
                        response += f"- **{col}:** Min = {min_val:.2f}, Max = {max_val:.2f}\n"
                    return response
                
                elif "padr√µes" in user_message.lower() or "tend√™ncias" in user_message.lower():
                    if analysis_context:
                        return f"**An√°lise de Padr√µes e Tend√™ncias:**\n{analysis_context[:500]}..."
                    else:
                        return "**An√°lise de Padr√µes:** Execute uma an√°lise CrewAI primeiro para obter insights sobre padr√µes e tend√™ncias nos dados."
            
            return "Desculpe, houve um problema t√©cnico. Tente novamente ou execute uma an√°lise CrewAI primeiro."
            
        except Exception as e:
            return f"Erro no sistema: {str(e)}"
    
    def analyze_data_context(self, df: pd.DataFrame, analysis_name: str = "An√°lise CSV") -> str:
        """Gera contexto sobre os dados para a IA"""
        if df is None:
            return "Nenhum dado carregado."
        
        # An√°lise b√°sica dos dados
        numeric_cols = df.select_dtypes(include=['number']).columns.tolist()
        categorical_cols = df.select_dtypes(include=['object']).columns.tolist()
        
        # Gerar insights das visualiza√ß√µes
        visualization_insights = ""
        try:
            visualization_insights = generate_visualization_insights(df)
        except Exception as e:
            visualization_insights = f"Erro ao gerar insights de visualiza√ß√£o: {str(e)}"
        
        context = f"""
CONTEXTO DOS DADOS:
- Nome: {analysis_name}
- Registros: {len(df):,}
- Colunas: {len(df.columns)}
- Num√©ricas: {len(numeric_cols)} ({', '.join(numeric_cols[:3])}{'...' if len(numeric_cols) > 3 else ''})
- Categ√≥ricas: {len(categorical_cols)} ({', '.join(categorical_cols[:3])}{'...' if len(categorical_cols) > 3 else ''})

INSIGHTS DAS VISUALIZA√á√ïES (Matplotlib/Seaborn):
{visualization_insights}

BIBLIOTECAS DE VISUALIZA√á√ÉO DISPON√çVEIS:
- Matplotlib: Para gr√°ficos b√°sicos e personalizados
- Seaborn: Para visualiza√ß√µes estat√≠sticas avan√ßadas
- Plotly: Para gr√°ficos interativos
- Pandas: Para visualiza√ß√µes integradas
"""
        
        return context
    
    def suggest_enhanced_questions(self, df: pd.DataFrame = None) -> list:
        """Sugere perguntas baseadas nos dados e an√°lises dispon√≠veis"""
        suggestions = []
        
        # Sugest√µes gerais
        suggestions.extend([
            "ü§ñ Execute uma an√°lise completa com os agentes CrewAI",
            "üìä Quais s√£o as principais conclus√µes da an√°lise?",
            "üîç O que os agentes descobriram sobre os dados?",
            "üìà Existem padr√µes ou tend√™ncias interessantes?",
            "‚ö†Ô∏è H√° anomalias ou outliers nos dados?",
            "üîó Quais s√£o as correla√ß√µes entre as vari√°veis?",
            "üéØ Que recomenda√ß√µes estrat√©gicas os agentes fizeram?",
            "üìã Resuma os insights mais importantes"
        ])
        
        # Sugest√µes que GERAM GR√ÅFICOS
        suggestions.extend([
            "üìä Mostre a distribui√ß√£o dos dados em um histograma",
            "üìà Visualize as correla√ß√µes entre as vari√°veis",
            "üìâ Crie um gr√°fico de box plot para detectar outliers",
            "üìä Mostre os valores mais altos e mais baixos",
            "üìà Como est√£o distribu√≠dos os dados ao longo do tempo?",
            "üìä Crie um gr√°fico de barras das categorias mais comuns",
            "üìà Mostre a evolu√ß√£o dos dados em um gr√°fico de linha",
            "üìä Visualize a matriz de correla√ß√£o em um heatmap"
        ])
        
        # Sugest√µes espec√≠ficas se h√° an√°lise CrewAI
        if analysis_memory.current_analysis:
            suggestions.extend([
                "üîç Quais foram as conclus√µes do Data Validator?",
                "üìä O que o Data Profiler descobriu?",
                "üéØ Que padr√µes o Pattern Detective identificou?",
                "‚ö†Ô∏è Quais anomalias o Anomaly Hunter encontrou?",
                "üîó O que o Relationship Analyst descobriu?",
                "üéØ Quais s√£o as recomenda√ß√µes do Strategic Synthesizer?",
                "üìà Mostre um resumo executivo da an√°lise"
            ])
        
        # Sugest√µes baseadas nos dados
        if df is not None:
            numeric_cols = df.select_dtypes(include=['number']).columns
            categorical_cols = df.select_dtypes(include=['object']).columns
            
            if len(numeric_cols) > 0:
                suggestions.append(f"üìä Analise a correla√ß√£o entre {', '.join(numeric_cols[:3])}")
                suggestions.append(f"üìà Mostre a distribui√ß√£o de {numeric_cols[0]} em um histograma")
                suggestions.append(f"üìâ Crie um box plot para {numeric_cols[0]}")
            
            if len(categorical_cols) > 0:
                suggestions.append(f"üìã Quais s√£o as categorias mais comuns em {categorical_cols[0]}?")
                suggestions.append(f"üìä Mostre um gr√°fico de barras de {categorical_cols[0]}")
            
            # Verificar se h√° coluna de tempo
            time_cols = [col for col in df.columns if 'time' in col.lower() or 'date' in col.lower()]
            if time_cols:
                suggestions.append(f"üìÖ Mostre a evolu√ß√£o dos dados ao longo do tempo ({time_cols[0]})")
        
        return suggestions[:16]  # Aumentar para 16 sugest√µes (8 gerais + 8 com gr√°ficos)
    
    def _handle_execute_analysis_request(self, df: pd.DataFrame, analysis_name: str) -> tuple:
        """
        Lida com solicita√ß√µes para executar an√°lise CrewAI
        
        Args:
            df: DataFrame com os dados
            analysis_name: Nome da an√°lise
        
        Returns:
            Tuple[str, Optional[go.Figure]]: (resposta_texto, grafico)
        """
        try:
            # Executar an√°lise CrewAI
            analysis_id = self.run_crewai_analysis(df, analysis_name)
            
            if analysis_id:
                # Obter contexto da an√°lise executada
                analysis_context = self.get_analysis_context(analysis_id)
                
                return (f"""
ü§ñ **An√°lise CrewAI Executada com Sucesso!**

‚úÖ **ID da An√°lise:** {analysis_id}
üìä **Dados Analisados:** {len(df):,} registros, {len(df.columns)} colunas
üìÖ **Data/Hora:** {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}

**üìã Resumo da An√°lise:**
{analysis_memory.get_analysis_summary(analysis_id)}

**üéØ Pr√≥ximos Passos:**
- Use a aba "üéØ Conclus√µes" para ver insights detalhados
- Fa√ßa perguntas espec√≠ficas sobre as descobertas
- Explore os resultados de cada agente individualmente

**üí° Sugest√µes de Perguntas:**
- "Quais foram as principais conclus√µes da an√°lise?"
- "O que o Data Validator descobriu sobre a qualidade dos dados?"
- "Que padr√µes o Pattern Detective identificou?"
- "H√° anomalias nos dados? O que o Anomaly Hunter encontrou?"
- "Quais s√£o as recomenda√ß√µes estrat√©gicas?"

A an√°lise est√° completa e pronta para explora√ß√£o! üöÄ
""", None)
            else:
                return ("""
‚ùå **Erro ao Executar An√°lise CrewAI**

N√£o foi poss√≠vel executar a an√°lise com os agentes CrewAI. Poss√≠veis causas:

1. **Chave de API n√£o configurada:** Verifique se a OPENAI_API_KEY est√° definida no arquivo .env
2. **Erro na conex√£o:** Verifique sua conex√£o com a internet
3. **Dados inv√°lidos:** Verifique se o arquivo CSV est√° carregado corretamente

**üí° Solu√ß√µes:**
- Configure sua chave de API OpenAI na barra lateral
- Verifique se o arquivo .env existe e cont√©m a chave correta
- Tente carregar o arquivo CSV novamente

Para mais ajuda, consulte a documenta√ß√£o ou entre em contato com o suporte.
""", None)
                
        except Exception as e:
            return (f"""
‚ùå **Erro ao Executar An√°lise CrewAI**

**Erro:** {str(e)}

**üí° Solu√ß√µes:**
1. Verifique se a chave de API OpenAI est√° configurada
2. Confirme se o arquivo .env existe e cont√©m OPENAI_API_KEY
3. Verifique sua conex√£o com a internet
4. Tente novamente em alguns minutos

Se o problema persistir, consulte a documenta√ß√£o ou entre em contato com o suporte.
""", None)

def show_enhanced_chat_interface(api_provider: str, api_key: str, df: pd.DataFrame = None, 
                                analysis_name: str = "An√°lise CSV"):
    """Interface de chat melhorada com integra√ß√£o CrewAI"""
    
    # Inicializar chat AI
    chat_ai = EnhancedChatAI(api_provider, api_key)
    
    # Inicializar sess√£o
    if "messages" not in st.session_state:
        st.session_state.messages = []
    
    if "analysis_id" not in st.session_state:
        st.session_state.analysis_id = None
    
    # Sidebar com controles
    with st.sidebar:
        st.markdown("### ü§ñ Controles de An√°lise")
        
        # Bot√£o para executar an√°lise CrewAI
        if st.button("üöÄ Executar An√°lise CrewAI", type="primary"):
            if df is not None:
                with st.spinner("Executando an√°lise com agentes CrewAI..."):
                    analysis_id = chat_ai.run_crewai_analysis(df, analysis_name)
                    if analysis_id:
                        st.session_state.analysis_id = analysis_id
                        st.success(f"‚úÖ An√°lise conclu√≠da! ID: {analysis_id}")
            else:
                st.warning("‚ö†Ô∏è Carregue um arquivo CSV primeiro")
        
        # Mostrar an√°lise atual
        if analysis_memory.current_analysis:
            st.markdown("### üìä An√°lise Atual")
            st.info(f"ID: {analysis_memory.current_analysis}")
            
            # Bot√£o para ver resumo
            if st.button("üìã Ver Resumo da An√°lise"):
                summary = analysis_memory.get_analysis_summary()
                st.markdown(summary)
        
        # Hist√≥rico de an√°lises
        history = analysis_memory.get_analysis_history()
        if history:
            st.markdown("### üìö Hist√≥rico de An√°lises")
            for analysis_id, info in list(history.items())[-5:]:  # √öltimas 5
                if st.button(f"üìÑ {info['analysis_name']} ({analysis_id})"):
                    st.session_state.analysis_id = analysis_id
                    analysis_memory.current_analysis = analysis_id
                    st.rerun()
    
    # √Årea principal do chat
    st.markdown("### üí¨ Chat com Agentes de IA")
    
    # Mostrar mensagens
    for message in st.session_state.messages:
        with st.chat_message(message["role"]):
            st.markdown(message["content"])
    
    # Sugest√µes de perguntas
    suggestions = chat_ai.suggest_enhanced_questions(df)
    if suggestions:
        st.markdown("#### üí° Sugest√µes de Perguntas:")
        
        # Dividir sugest√µes em 2 colunas
        col1, col2 = st.columns(2)
        
        # Dividir a lista de sugest√µes ao meio
        mid_point = len(suggestions) // 2
        suggestions_col1 = suggestions[:mid_point]
        suggestions_col2 = suggestions[mid_point:]
        
        # Coluna 1
        with col1:
            for suggestion in suggestions_col1:
                st.markdown(f"‚Ä¢ {suggestion}")
        
        # Coluna 2
        with col2:
            for suggestion in suggestions_col2:
                st.markdown(f"‚Ä¢ {suggestion}")
    
    # Input do usu√°rio
    if prompt := st.chat_input("Fa√ßa uma pergunta sobre os dados ou an√°lises..."):
        # Adicionar mensagem do usu√°rio
        st.session_state.messages.append({"role": "user", "content": prompt})
        
        # Mostrar mensagem do usu√°rio
        with st.chat_message("user"):
            st.markdown(prompt)
        
        # Gerar resposta
        with st.chat_message("assistant"):
            with st.spinner("Pensando..."):
                response, chart = chat_ai.generate_enhanced_response(prompt, df, analysis_name)
                st.markdown(response)
                
                # Mostrar gr√°fico se dispon√≠vel
                if chart:
                    st.plotly_chart(chart, use_container_width=True)
        
        # Adicionar resposta √†s mensagens
        st.session_state.messages.append({"role": "assistant", "content": response})
    
    # Bot√µes de a√ß√£o
    col1, col2, col3 = st.columns(3)
    
    with col1:
        if st.button("üóëÔ∏è Limpar Chat"):
            st.session_state.messages = []
            st.rerun()
    
    with col2:
        if st.button("üì• Exportar Conversa"):
            if st.session_state.messages:
                export_data = {
                    "conversation": st.session_state.messages,
                    "analysis_id": st.session_state.analysis_id,
                    "timestamp": datetime.now().isoformat()
                }
                json_str = json.dumps(export_data, ensure_ascii=False, indent=2)
                st.download_button(
                    label="üìÑ Download JSON",
                    data=json_str,
                    file_name=f"chat_export_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json",
                    mime="application/json"
                )
    
    with col3:
        if st.button("üß† Limpar Mem√≥ria"):
            if analysis_memory.clear_analysis_memory():
                st.success("‚úÖ Mem√≥ria de an√°lises limpa!")
                st.session_state.analysis_id = None
                st.rerun()
            else:
                st.error("‚ùå Erro ao limpar mem√≥ria")
